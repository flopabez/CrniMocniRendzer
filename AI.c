#include <stdlib.h>
#include <time.h>
#include "AI.h"
#define EASY_LEN 50
#define MEDIUM_LEN 20
#define HARD_LEN 5

typedef struct Tank Tank;
typedef struct gameState gameState;

//Singly linked list. Contains the moves that the tank needs to make along with the coordinates the tank will have afterwards. When we call truncate on it, we'll return a string containing a specified first number of characters.
typedef struct tankPath tankPath;

//Queue in which we put the various paths generated by our search algorithms (we will use BFS and Dijkstra).
typedef struct tankPathNode tankPathNode;

tankPath* addPath(tankPath *P, char dir, int x, int y, int len)
{
    tankPath *Q=(tankPath*)(malloc(sizeof(tankPath)));
    Q->dir=dir;
    Q->x=x;
    Q->y=y;
    Q->len=len;
    Q->parent=P;
    return Q;
}


//Enqueue and dequeue functions for the queue of paths/move lists
void enqPathNode(tankPathNode **frontNode, tankPathNode **rearNode, tankPath* P)
{
    tankPathNode *newNode;
    newNode=(tankPathNode*)(malloc(sizeof(tankPathNode)));
    newNode->next=NULL;
    newNode->P=P;
    if (*frontNode==NULL)
        (*frontNode)=newNode;
    else
        (*rearNode)->next=newNode;
    (*rearNode)=newNode;
}
tankPath* deqPathNode(tankPathNode **frontNode, tankPathNode **rearNode)
{
    tankPath* t;
    tankPathNode* temp;
    if (*frontNode==NULL) return NULL;
    if (*frontNode==*rearNode) *rearNode=NULL;

    temp=*frontNode;
    t=temp->P;
    *frontNode=(*frontNode)->next;
    free(temp);
    return t;
}

int tileFree(int x,int y,gameState G)
{
    //Return 1 if (x,y) is within matrix bounds and the coords of a floor tile
    int h=G.height;
    int w=G.width;
    return (x>=0&&x<h&&y>=0&&y<w&&(G.terrain)[x][y]==0);
}

//Array containing coordinate changes for each of the four directions: N,E,S,W in that order
int dArr[4][2]={{-1,0},{0,1},{1,0},{0,-1}};

char* truncatePath(tankPath **P, int l)
{
    tankPath *temp;
    int N=(*P)->len,i;
    char *A=(char*)(malloc(l+1));
    for (i=N;i>=0&&(*P);i--)
    {
        temp=*P;
        if (i<l) A[i]=temp->dir;
        (*P)=(*P)->parent;
        free(temp);
    }
    A[l]='\0';
    return A;
}

//Easy (brain-dead) difficulty tanks move randomly
char* easyPath(Tank *T, gameState G, int xt, int yt)
{
    //Initialize the starting coordinates to those of the calling tank
    int i,j,num_dir,dx,dy;
    char choose_dir[4],randDir;
    int x=T->xPos,y=T->yPos;
    tankPath *P=NULL;
    for (i=0;i<EASY_LEN;i++)
    {
        //Reset the initial number of unblocked paths the tank has available
        num_dir=0;
        //Scan all 4 directions - any that lead to unoccupied tiles are added to the random choice array
        for (j=0;j<4;j++)
        {
            dx=dArr[j][0],dy=dArr[j][1];
            if  (tileFree(x+dx,y+dy,G)) choose_dir[num_dir++]=j;
        }
        //Pick a random available tile using the random choice array
        if (num_dir)
        {
            //If it exists (and it should, a tank cannot box itself in), add the direction we picked to the move list and adjust the tank's coords
            randDir=choose_dir[rand()%num_dir];
            x+=dArr[randDir][0],y+=dArr[randDir][1];
            P=addPath(P,randDir,x,y,P->len+1);
        }
    }
    return truncatePath(&P,EASY_LEN);
}

//Medium tanks call BFS to pathfind every 20 moves, so we'll just BFS to the target (xt,yt) and then return the first 20 moves of that BFS.
//Unlike hard tanks, they cannot consider breakable walls when finding a path, nor do they know how to dodge bullets.
char* mediumPath(Tank *T, gameState G, int xt, int yt, char *resetVM)
{
    int h=G.height,w=G.width,i,j,x,y;
    //We're keeping our visit matrix static so as to prevent collision between multiple tanks all calling the same BFS routine. Each game cycle, on the first BFS call of that cycle we zero-reset it.
    static char vMat[1000][1000];
    if (*resetVM)
    {
        *resetVM=0;
        for (i=0;i<h;i++)
            for (j=0;j<w;j++) vMat[i][j]=0;
    }
    //Queue initialization
    tankPathNode *frontNode=NULL,*rearNode=NULL;
    //The first movelist we're adding to the queue is just the tank's starting position
    tankPath* P=addPath(NULL,-1,T->xPos,T->yPos,0);
    enqPathNode(&frontNode,&rearNode,P);
    //Standard BFS - grab a movelist off the queue, check if it's the goal, if yes truncate and return it, if not add and visit-mark all of its non-visited successor states to the queue. Repeat until the queue is empty.
    while (frontNode)
    {
        P=deqPathNode(&frontNode,&rearNode);
        if (P->x==xt&&P->y==yt) return truncatePath(&P,MEDIUM_LEN);
        //We consider all possible tiles we can move to. If there's an adjacent floor tile that is either not yet planned for visitation or planned for visitation by someone who cannot get there before the current tank path,
        // we'll update the earliest possible visit time for that tile and add its corresponding movelist to the queue.
        for (i=0;i<4;i++)
        {
            x=P->x+dArr[i][0],y=P->y+dArr[i][1];
            if (tileFree(x,y,G)&&((vMat[x][y]==0)||(vMat[x][y]>P->len)))
            {
                vMat[x][y]=P->len+1;
                enqPathNode(&frontNode,&rearNode,addPath(P,i,x,y,P->len+1));
            }
        }

    }
    return NULL;
}


//Wrapper function that randomly chooses our tank's target and calls the appropriate pathfinding routine, depending on the difficulty.
char* choosePath(Tank *T, gameState G, int difficulty, char newCycle)
{
    srand(time(NULL));
    char resetVM=newCycle;
    int xt,yt,h=rand()%5;
    if (h==0)
    {
        xt=((Tank*)(G.playerTanks->data))->xPos;
        yt=((Tank*)(G.playerTanks->data))->yPos;
    }
    else
    {
        xt=G.xBase;
        yt=G.yBase;
    }
    if (difficulty==0) return easyPath(T,G,xt,yt);
    else if (difficulty==1) return mediumPath(T,G,xt,yt,&resetVM);
    return NULL;
}
